% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/retrieveClassificationTable.R
\name{retrieveClassificationTable}
\alias{retrieveClassificationTable}
\title{Retrieve a classification table from CELLAR or FAO}
\usage{
retrieveClassificationTable(
  endpoint,
  prefix,
  conceptScheme,
  language = "en",
  level = "ALL",
  CSVout = NULL,
  showQuery = FALSE,
  localData = NULL
)
}
\arguments{
\item{endpoint}{Character string specifying which SPARQL endpoint to query.
Must be one of:
\itemize{
  \item \code{"CELLAR"}
  \item \code{"FAO"}
}}

\item{prefix}{Character string giving the namespace prefix associated
with the targeted classification scheme.  
This value should match the \code{Prefix} column returned by
\code{\link{classificationEndpoint}} and is required to build:
\itemize{
  \item the \code{PREFIX} declarations (via \code{prefixList}),
  \item the fully-qualified scheme name (e.g. \code{prefix:conceptScheme}).
}}

\item{conceptScheme}{Character string identifying the classification
scheme to retrieve, typically obtained from the
\code{ConceptScheme} column of \code{\link{classificationEndpoint}}.}

\item{language}{Character string giving the language used for labels and
notes. Defaults to \code{"en"}.}

\item{level}{Character string specifying which hierarchical level to
retrieve.  
\itemize{
  \item \code{"ALL"} (default): retrieve every level.
  \item A numeric depth (e.g. \code{"1"}, \code{"2"}): retrieve only
        that level.
}
If the classification has no defined levels (as detected by
\code{\link{dataStructure}}), the function automatically resets
\code{level = "ALL"} with a message.}

\item{CSVout}{Logical or character. Controls CSV export:
\itemize{
  \item \code{NULL} (default): no export.
  \item \code{TRUE}: export to a default filename based on
        \code{prefix} and \code{language}.
  \item character: explicit path to a CSV file.
}}

\item{showQuery}{Logical. If \code{TRUE} (default), returns a list
containing both the SPARQL query and the resulting table.  
If \code{FALSE}, only the table (data frame) is returned.}

\item{localData}{Logical (reserved for future use).
When the global option \code{useLocalDataForVignettes = TRUE} is set,
the function attempts to read an embedded CSV file instead of querying
the live endpoints.}
}
\value{
If \code{showQuery = TRUE} (default), returns a list with:
\itemize{
  \item \code{SPARQL.query}: the full SPARQL query as a character string,
  \item \code{ClassificationTable}: a data frame containing the retrieved
        classification table.
}

If \code{showQuery = FALSE}, only the classification table is returned.
}
\description{
Retrieves a full classification table codes, labels, hierarchical
relationships, and associated notes from the CELLAR or FAO SPARQL
repositories.  
The function supports optional filtering by hierarchical level and
automatic use of local embedded data for vignette building.
}
\details{
Behaviour depends on the global option
\code{useLocalDataForVignettes}:
\itemize{
  \item If \code{TRUE}:  
        the function searches for a local embedded CSV file (in
        \code{inst/extdata}) matching the requested \code{prefix} and
        \code{language}.  
        If found, it is returned immediately and no SPARQL call is made.

  \item If \code{FALSE}:  
        the function:
        \itemize{
          \item builds SPARQL prefix declarations via
                \code{prefixList},
          \item calls \code{\link{dataStructure}} to determine level
                availability and adjust \code{level} when necessary,
          \item constructs and submits a SPARQL query to the selected
                endpoint,
          \item returns the resulting classification table, optionally
                along with the query used.
        }
}

Clear, user-friendly errors are raised if:
\itemize{
  \item the endpoint is unreachable,
  \item the classification does not provide the requested level,
  \item \code{dataStructure()} indicates missing or invalid structure information,
  \item the SPARQL response is malformed.
}
}
\examples{
\dontrun{
  endpoint <- "CELLAR"
  prefix <- "cn2022"
  conceptScheme <- "cn2022"

  res <- tryCatch(
    retrieveClassificationTable(
      endpoint      = endpoint,
      prefix        = prefix,
      conceptScheme = conceptScheme,
      language      = "en",
      level         = "ALL"
    ),
    error = function(e) {
      message("SPARQL query failed: ", e$message)
      NULL
    }
  )

  if (!is.null(res)) {
    cat(res$SPARQL.query)
    head(res$ClassificationTable)
  }
}

}
\seealso{
\code{\link{classificationEndpoint}},
\code{\link{dataStructure}}
}
